---
title: 虚拟地址
date: 2022-11-15 03:40:44
tags: csapp
categories: 操作系统
---
### 1.物理和虚拟寻址
&emsp;&emsp;现代处理器使用的是一种称为虚拟寻址的寻址方式。<!--more-->
![](/img/寻址.png)
### 2．页表
&emsp;&emsp;虚拟内存系统必须有某种方法来判断一个虚拟页是否缓存在DRAM中的某个地方，并且如何找到它。这些功能是由软硬件联合提供的，包括OS软件，MMU（内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫做页表的数据结构，页表将虚拟页映射到物理页。
![](/img/页表.png)
有效位和地址：
有效位为1，地址字段表示了DRAM中相应的物理页的起始位置（已分配已缓存）
有效位为0，地址字段非空，地址字段则表示该虚拟页在磁盘中的位置（已分配未缓存）
有效位为0，地址字段空，未分配未缓存
### 3.页命中
&emsp;&emsp;考虑一下当CPU想要读包含在VP 2中的虚拟内存的-一个字时会发生什么(图9-5)，VP2被缓存在DRAM中。使用我们将在9.6节中详细描述的一种技术，地址翻译硬件将虚拟地址作为一个索引来定位PTE2，并从内存中读取它。因为设置了有效位，那么地址翻译硬件就知道VP2是缓存在内存中的了。所以它使用PTE中的物理内存地址(该地址指向PP1中缓存页的起始位置)，构造出这个字的物理地址。
![](/img/页命中.png)
### 4.缺页
&emsp;&emsp;在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(page fault)。图9-6展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择-一个牺牲页，在此例中就是存放在PP 3中的VP4。如果VP 4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。
![](/img/缺页1.png)
&emsp;&emsp;接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图9-7展示了在缺页之后我们的示例页表的状态。
![](/img/缺页2.png)
### 5.全过程
&emsp;&emsp;程序运行时内核为程序建立页表，页表由内核维护。页表存在两个映射，一个映射到磁盘的目标执行文件（虚拟地址与磁盘的映射），另一个映射到真实物理内存（虚拟地址与物理内存地址映射）。内核调度CPU到页表第一页执行程序，从main函数开始。CPU发现第一页并没有加载到物理内存，发生缺页异常，CPU把磁盘上对应的目标程序的页加载到物理内存，并改变页表状态（映射）。CPU重新读取页内容执行，此时不再有缺页异常。
&emsp;&emsp;程序从main函数开始，函数是一个栈，执行前先分配栈内存，这部分代码由编译器生成，CPU执行前,这部分栈内存地址是虚拟地址，需要映射到真实的物理地址，然后开始执行函数内容，假设函数第一条语句是int a=1;则a的地址（虚拟地址）内存存入1，通过mmu把1放入真实的对应的物理地址内存。再假设第二句语句是一个函数fun()调用，过程类似main函数，fun函数执行完毕释放内存，销毁映射。
![](/img/全过程.png)


