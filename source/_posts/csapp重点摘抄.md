---
title: 内存共享、写时复制
date: 2022-11-13 23:42:12
tags: csapp
categories: 操作系统
---
### <font size=6 >1.共享对象</font>
&emsp;&emsp; 内存映射的概念来源于-一个聪明的发现:如果虚拟内存系统可以集成到传统的文件系统中，那么就能提供一种简单而高效的把程序和数据加载到内存中的方法。<!--more-->
&emsp;&emsp;正如我们已经看到的，进程这一抽象能够为每个进程提供自己私有的虚拟地址空间，可以免受其他进程的错误读写。不过，许多进程有同样的只读代码区域。例如，每个运行Linux shell程序bash的进程都有相同的代码区域。而且，许多程序需要访问只读运行时库代码的相同副本。例如，每个C程序都需要来自标准C库的诸如printf这样的函数。那么，如果每个进程都在物理内存中保持这些常用代码的副本，那就是极端的浪费了。幸运的是，内存映射给我们提供了一种清晰的机制，用来控制多个进程如何共享对象。
&emsp;&emsp;一个对象可以被映射到虛拟内存的一个区域，要么作为共享对象，要么作为私有对象。如果一个进程将--个共享对象映射到它的虚拟地址空间的一一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虛拟内存的其他进程而言，也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。
&emsp;&emsp;另一方面，对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟内存区域叫做共享区域。类似地，也有私有区域。
&emsp;&emsp;假设进程1将一个共享对象映射到它的虚拟内存的一个区域中，如图9-29a所示。现在假设进程2将同一个共享对象映射到它的地址空间(并不-定要和进程1在相同的虛拟地址处，如图9-29b所示)。
![csapp](/img/9-29b.png)
&emsp;&emsp;因为每个对象都有一个唯- -的文件名，内核可以迅速地判定进程1已经映射了这个对象，而且可以使进程2中的页表条目指向相应的物理页面。关键点在于即使对象被映射到了多个共享区域，物理内存中也只需要存放共享对象的一个副本。为了方便，我们将物理页面显示为连续的，但是在一般情况下当然不是这样的。
### 2.写时复制
&emsp;&emsp;私有对象使用一种叫做写时复制(copyon-write)的巧妙技术被映射到虚拟内存中。一个私有对象开始生命周期的方式基本上与共享对象的一-样，在物理内存中只保存有私有对象的-份副本。比如，图9-30a展示了一种情况，其中两个进程将-一个私有对象映射到它们虚拟内存的不同区域，但是共享这个对象同-一个物理副本。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理内存中对象的-一个单独副本。然而，只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个保护故障。
&emsp;&emsp;当故障处理程序注意到保护异常是由于进程试图写私有的写时复制区域中的一个页面而引起的，它就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限，如图9-30b所示。当故障处理程序返回时，CPU重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。
![csapp](/img/9-30a.jpg)
&emsp;&emsp;通过延迟私有对象中的副本直到最后可能的时刻，写时复制最充分地使用了稀有的物理内存。
### *3.fork函数*
&emsp;&emsp;既然我们理解了虚拟内存和内存映射，那么我们可以清晰地知道fork 函数是如何创建一个带有自己独立虚拟地址空间的新进程的。
&emsp;&emsp;当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct:t、 区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。
&emsp;&emsp;当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。




